import{d as Br,e as c,g as qr,h as y,l as g,K as oe,L as dr,j as M,D as ae,E as w,H as z,T as H,k as f,m as k,n as fe,o as ce,p as Tr,q as Pr,s as T,r as ie,u as lr,v as gr,w as yr,x as hr,I as F,M as pr,y as W,A as Ur,z as Vr,B as ve,F as Nr,U as Ne,G as Z,S as xe,J as Ae,N as de,O as Le,P as b,Q as _,R as ne,V as P,W as Y,X as K,Y as xr}from"./index-DOJHP7J4.js";import{U as m,E as Ar,a as J,C as Fe,R,H as X,D as je,b as O,K as Lr,c as Fr,d as jr,S as Gr,e as Wr,T as Jr,f as Hr,g as Yr,P as Qr,h as Ge,Q as We,V as B,i as $r,j as ee,k as U,B as x,l as zr,L as Je,O as Zr,m as Xr,n as et,o as rt,p as He,q as fr,r as Ye,s as tt,M as it,t as q,u as Qe,v as V,w as vr,x as mr,y as kr,z as nt,A as Te,F as st,G as ot,I as le,J as at}from"./matrix-sdk-crypto-wasm-D9e1T4vy.js";try{let e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},r=(new e.Error).stack;r&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[r]="4f585346-5dc5-4118-89e8-f884e2e1d44e",e._sentryDebugIdIdentifier="sentry-dbid-4f585346-5dc5-4118-89e8-f884e2e1d44e")}catch{}var j=function(e){return e.Change="change",e}({}),S=function(e){return e[e.Unsent=1]="Unsent",e[e.Requested=2]="Requested",e[e.Ready=3]="Ready",e[e.Started=4]="Started",e[e.Cancelled=5]="Cancelled",e[e.Done=6]="Done",e}({}),Sr=function(e){return e.Cancel="cancel",e.ShowSas="show_sas",e.ShowReciprocateQr="show_reciprocate_qr",e}({}),ge=[139,1];function $e(e){var r,t=new Uint8Array(ge.length+e.length+1);t.set(ge,0),t.set(e,ge.length);for(var n=0,i=0;i<t.length-1;++i)n^=t[i];return t[t.length-1]=n,null===(r=Br.encode(t).match(/.{1,4}/g))||void 0===r?void 0:r.join(" ")}var ye,ze,ct=256;function _r(e,r,t){return me.apply(this,arguments)}function me(){return me=c((function*(e,r,t){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ct;if(!globalThis.crypto.subtle||!TextEncoder)throw new Error("Password-based backup is not available on this platform");var i=yield globalThis.crypto.subtle.importKey("raw",(new TextEncoder).encode(e),{name:"PBKDF2"},!1,["deriveBits"]),o=yield globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:(new TextEncoder).encode(r),iterations:t,hash:"SHA-512"},i,n);return new Uint8Array(o)})),me.apply(this,arguments)}function ut(){if(ze)return ye;ze=1;for(var e=/[\\\"\x00-\x1F]/g,r={},t=0;t<32;++t)r[String.fromCharCode(t)]="\\U"+("0000"+t.toString(16)).slice(-4).toUpperCase();function n(t){return e.lastIndex=0,t.replace(e,(function(e){return r[e]}))}function i(e){switch(typeof e){case"string":return'"'+n(e)+'"';case"number":return isFinite(e)?e:"null";case"boolean":return e;case"object":return null===e?"null":Array.isArray(e)?function(e){for(var r="[",t="",n=0;n<e.length;++n)t+=r,r=",",t+=i(e[n]);return","!=r?"[]":t+"]"}(e):function(e){var r="{",t="",o=Object.keys(e);o.sort();for(var s=0;s<o.length;++s){var a=o[s];t+=r+'"'+n(a)+'":',r=",",t+=i(e[a])}return","!=r?"{}":t+"}"}(e);default:throw new Error("Cannot stringify: "+typeof e)}}return r["\b"]="\\b",r["\t"]="\\t",r["\n"]="\\n",r["\f"]="\\f",r["\r"]="\\r",r['"']='\\"',r["\\"]="\\\\",ye={stringify:i}}var dt=ut();const lt=qr(dt);class gt{constructor(e,r,t,n,i){this.olmMachine=e,this.keyClaimManager=r,this.outgoingRequestManager=t,this.room=n,this.encryptionSettings=i,y(this,"prefixedLogger",void 0),y(this,"lazyLoadedMembersResolved",!1),y(this,"currentEncryptionPromise",Promise.resolve()),this.prefixedLogger=g.getChild("[".concat(n.roomId," encryption]"));var o=n.getJoinedMembers();this.olmMachine.updateTrackedUsers(o.map((e=>new m(e.userId)))).catch((e=>this.prefixedLogger.error("Error initializing tracked users",e)))}onCryptoEvent(e){if(JSON.stringify(this.encryptionSettings)!=JSON.stringify(e))throw new Error("Cannot reconfigure an active RoomEncryptor")}onRoomMembership(e){(e.membership==oe.Join||e.membership==oe.Invite&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new m(e.userId)]).catch((e=>{this.prefixedLogger.error("Unable to update tracked users",e)}))}prepareForEncryption(e,r){var t=this;return c((function*(){yield t.encryptEvent(null,e,r)}))()}encryptEvent(e,r,t){var n,i=this,o=new dr(this.prefixedLogger,e?null!==(n=e.getTxnId())&&void 0!==n?n:"":"prepareForEncryption"),s=this.currentEncryptionPromise.catch((()=>{})).then(c((function*(){yield M(o,"ensureEncryptionSession",c((function*(){yield i.ensureEncryptionSession(o,r,t)}))),e&&(yield M(o,"encryptEventInner",c((function*(){yield i.encryptEventInner(o,e)}))))})));return this.currentEncryptionPromise=s,s}ensureEncryptionSession(e,r,t){var n=this;return c((function*(){if("m.megolm.v1.aes-sha2"!==n.encryptionSettings.algorithm)throw new Error("Cannot encrypt in ".concat(n.room.roomId," for unsupported algorithm '").concat(n.encryptionSettings.algorithm,"'"));e.debug("Starting encryption");var i=yield n.room.getEncryptionTargetMembers();n.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),n.outgoingRequestManager.doProcessOutgoingRequests()):(yield M(n.prefixedLogger,"loadMembersIfNeeded: updateTrackedUsers",c((function*(){yield n.olmMachine.updateTrackedUsers(i.map((e=>new m(e.userId))))}))),e.debug("Updated tracked users"),n.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),yield M(n.prefixedLogger,"doProcessOutgoingRequests",c((function*(){yield n.outgoingRequestManager.doProcessOutgoingRequests()})))),e.debug("Encrypting for users (shouldEncryptForInvitedMembers: ".concat(n.room.shouldEncryptForInvitedMembers(),"):"),i.map((e=>"".concat(e.userId," (").concat(e.membership,")"))));var o=i.map((e=>new m(e.userId)));yield M(n.prefixedLogger,"ensureSessionsForUsers",c((function*(){yield n.keyClaimManager.ensureSessionsForUsers(e,o)})));var s=new Ar;switch(s.historyVisibility=yt(n.room.getHistoryVisibility()),s.algorithm=J.MegolmV1AesSha2,"number"==typeof n.encryptionSettings.rotation_period_ms&&(s.rotationPeriod=BigInt(1e3*n.encryptionSettings.rotation_period_ms)),"number"==typeof n.encryptionSettings.rotation_period_msgs&&(s.rotationPeriodMessages=BigInt(n.encryptionSettings.rotation_period_msgs)),t.kind){case ae.AllDevicesIsolationMode:var a,u=null!==(a=n.room.getBlacklistUnverifiedDevices())&&void 0!==a?a:r;s.sharingStrategy=Fe.deviceBasedStrategy(u,t.errorOnVerifiedUserProblems);break;case ae.OnlySignedDevicesIsolationMode:s.sharingStrategy=Fe.identityBasedStrategy()}yield M(n.prefixedLogger,"shareRoomKey",c((function*(){var e=yield n.olmMachine.shareRoomKey(new R(n.room.roomId),o,s);if(e)for(var r of e)yield n.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(r)})))}))()}forceDiscardSession(){var e=this;return c((function*(){(yield e.olmMachine.invalidateGroupSession(new R(e.room.roomId)))&&e.prefixedLogger.info("Discarded existing group session")}))()}encryptEventInner(e,r){var t=this;return c((function*(){e.debug("Encrypting actual message content");var n=yield t.olmMachine.encryptRoomEvent(new R(t.room.roomId),r.getType(),JSON.stringify(r.getContent()));r.makeEncrypted(w.RoomMessageEncrypted,JSON.parse(n),t.olmMachine.identityKeys.curve25519.toBase64(),t.olmMachine.identityKeys.ed25519.toBase64()),e.debug("Encrypted event successfully")}))()}}function yt(e){switch(e){case z.Invited:return X.Invited;case z.Joined:return X.Joined;case z.Shared:return X.Shared;case z.WorldReadable:return X.WorldReadable}}var G="/_matrix/client/unstable/org.matrix.msc3814.v1",he="org.matrix.msc3814",ht=6048e5;class pt extends H{constructor(e,r,t,n,i){super(),this.logger=e,this.olmMachine=r,this.http=t,this.outgoingRequestProcessor=n,this.secretStorage=i,y(this,"intervalId",void 0)}cacheKey(e){var r=this;return c((function*(){yield r.olmMachine.dehydratedDevices().saveDehydratedDeviceKey(e),r.emit(f.DehydrationKeyCached)}))()}isSupported(){var e=this;return c((function*(){try{yield e.http.authedRequest(k.Get,"/dehydrated_device",void 0,void 0,{prefix:G})}catch(e){var r=e;if("M_UNRECOGNIZED"===r.errcode)return!1;if("M_NOT_FOUND"===r.errcode)return!0;throw e}return!0}))()}start(){var e=arguments,r=this;return c((function*(){var t=e.length>0&&void 0!==e[0]?e[0]:{};if("boolean"==typeof t&&(t={createNewKey:t}),!t.onlyIfKeyCached||(yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey())){if(r.stop(),!1!==t.rehydrate)try{yield r.rehydrateDeviceIfAvailable()}catch(e){r.logger.info("dehydration: Error rehydrating device:",e),r.emit(f.RehydrationError,e.message)}t.createNewKey&&(yield r.resetKey()),yield r.scheduleDeviceDehydration()}}))()}isKeyStored(){var e=this;return c((function*(){return!!(yield e.secretStorage.isStored(he))}))()}resetKey(){var e=this;return c((function*(){var r=je.createRandomKey();return yield e.secretStorage.store(he,r.toBase64()),yield e.cacheKey(r),r}))()}getKey(e){var r=this;return c((function*(){var t=yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey();if(t)return t;var n=yield r.secretStorage.get(he);if(void 0===n)return e?yield r.resetKey():null;var i=fe(n);try{var o=je.createKeyFromArray(i);return yield r.cacheKey(o),o}finally{i.fill(0)}}))()}rehydrateDeviceIfAvailable(){var e=this;return c((function*(){var r,t=yield e.getKey(!1);if(!t)return!1;try{r=yield e.http.authedRequest(k.Get,"/dehydrated_device",void 0,void 0,{prefix:G})}catch(r){var n=r;if("M_NOT_FOUND"===n.errcode||"M_UNRECOGNIZED"===n.errcode)return e.logger.info("dehydration: No dehydrated device"),!1;throw n}e.logger.info("dehydration: dehydrated device found"),e.emit(f.RehydrationStarted);var i=yield e.olmMachine.dehydratedDevices().rehydrate(t,new O(r.device_id),JSON.stringify(r.device_data));e.logger.info("dehydration: device rehydrated");for(var o=void 0,s=0,a=0,c=ce("/dehydrated_device/$device_id/events",{$device_id:r.device_id});;){var u=yield e.http.authedRequest(k.Post,c,void 0,o?{next_batch:o}:{},{prefix:G});if(0===u.events.length)break;s+=u.events.length,o=u.next_batch,a+=(yield i.receiveEvents(JSON.stringify(u.events))).length,e.emit(f.RehydrationProgress,a,s)}return e.logger.info("dehydration: received ".concat(a," room keys from ").concat(s," to-device events")),e.emit(f.RehydrationCompleted),!0}))()}createAndUploadDehydratedDevice(){var e=this;return c((function*(){var r=yield e.getKey(!0),t=yield e.olmMachine.dehydratedDevices().create();e.emit(f.DehydratedDeviceCreated);var n=yield t.keysForUpload("Dehydrated device",r);yield e.outgoingRequestProcessor.makeOutgoingRequest(n),e.emit(f.DehydratedDeviceUploaded),e.logger.info("dehydration: uploaded device")}))()}scheduleDeviceDehydration(){var e=this;return c((function*(){e.stop(),yield e.createAndUploadDehydratedDevice(),e.intervalId=setInterval((()=>{e.createAndUploadDehydratedDevice().catch((r=>{e.emit(f.DehydratedDeviceRotationError,r.message),e.logger.error("Error creating dehydrated device:",r)}))}),ht)}))()}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}delete(){var e=this;return c((function*(){e.stop();try{yield e.http.authedRequest(k.Delete,"/dehydrated_device",void 0,{},{prefix:G})}catch(e){var r=e;if("M_UNRECOGNIZED"===r.errcode)return;if("M_NOT_FOUND"===r.errcode)return;throw e}}))()}}function Ze(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function ft(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?Ze(Object(t),!0).forEach((function(r){y(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Ze(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}class vt{constructor(e,r){this.olmMachine=e,this.http=r}makeOutgoingRequest(e,r){var t=this;return c((function*(){var n;if(e instanceof Lr)n=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof Fr)n=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof jr)n=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof Gr)n=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof Wr)n=yield t.requestWithRetry(k.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof Jr)n=yield t.sendToDeviceRequest(e);else if(e instanceof Hr){var i="/_matrix/client/v3/rooms/".concat(encodeURIComponent(e.room_id),"/send/")+"".concat(encodeURIComponent(e.event_type),"/").concat(encodeURIComponent(e.txn_id));n=yield t.requestWithRetry(k.Put,i,{},e.body)}else{if(e instanceof Yr)return void(yield t.makeRequestWithUIA(k.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,r));if(e instanceof Qr){var o=G+"/dehydrated_device";return void(yield t.rawJsonRequest(k.Put,o,{},e.body))}g.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),n=""}if(e.id)try{yield M(g,"Mark Request as sent ".concat(e.type),c((function*(){yield t.olmMachine.markRequestAsSent(e.id,e.type,n)})))}catch(e){if(!(e instanceof Error)||"Attempt to use a moved value"!==e.message&&"null pointer passed to rust"!==e.message)throw e;g.log("Ignoring error '".concat(e.message,"': client is likely shutting down"))}else g.trace("Outgoing request type:".concat(e.type," does not have an ID"))}))()}sendToDeviceRequest(e){var r=this;return c((function*(){var t=JSON.parse(e.body),n=[];for(var[i,o]of Object.entries(t.messages))for(var[s,a]of Object.entries(o))n.push("".concat(i,"/").concat(s," (msgid ").concat(a[Tr],")"));g.info("Sending batch of to-device messages. type=".concat(e.event_type," txnid=").concat(e.txn_id),n);var c="/_matrix/client/v3/sendToDevice/".concat(encodeURIComponent(e.event_type),"/")+encodeURIComponent(e.txn_id);return yield r.requestWithRetry(k.Put,c,{},e.body)}))()}makeRequestWithUIA(e,r,t,n,i){var o=this;return c((function*(){if(!i)return yield o.requestWithRetry(e,r,t,n);var s,a=JSON.parse(n),u=(s=c((function*(n){var i=ft({},a);null!==n&&(i.auth=n);var s=yield o.requestWithRetry(e,r,t,JSON.stringify(i));return JSON.parse(s)})),function(e){return s.apply(this,arguments)}),d=yield i(u);return JSON.stringify(d)}))()}requestWithRetry(e,r,t,n){var i=this;return c((function*(){for(var o=0;;)try{return yield i.rawJsonRequest(e,r,t,n)}catch(e){o++;var s=Pr(e,o,!0);if(s<0)throw e;yield T(s)}}))()}rawJsonRequest(e,r,t,n){var i=this;return c((function*(){return yield i.http.authedRequest(e,r,t,n,{json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:"",localTimeoutMs:6e4})}))()}}class mt{constructor(e,r){this.olmMachine=e,this.outgoingRequestProcessor=r,y(this,"currentClaimPromise",void 0),y(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,r){var t=this.currentClaimPromise.catch((()=>{})).then((()=>this.ensureSessionsForUsersInner(e,r)));return this.currentClaimPromise=t,t}ensureSessionsForUsersInner(e,r){var t=this;return c((function*(){if(t.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");var n=yield t.olmMachine.getMissingSessions(r.map((e=>e.clone())));n&&(e.info("Making /keys/claim request"),yield t.outgoingRequestProcessor.makeOutgoingRequest(n)),e.info("Olm sessions prepared")}))()}}function kt(e,r){var t=new Map;for(var[n,i]of e.keys.entries())t.set(n.toString(),i.toBase64());var o=ie.Unverified;e.isBlacklisted()?o=ie.Blocked:e.isVerified()&&(o=ie.Verified);var s=new Map,a=e.signatures.get(r);if(a){var c=new Map;for(var[u,d]of a.entries())d.isValid()&&d.signature&&c.set(u,d.signature.toBase64());s.set(r.toString(),c)}var l=e.algorithms,g=new Set;return l.forEach((e=>{switch(e){case J.MegolmV1AesSha2:g.add("m.megolm.v1.aes-sha2");break;case J.OlmV1Curve25519AesSha2:default:g.add("m.olm.v1.curve25519-aes-sha2")}})),new lr({deviceId:e.deviceId.toString(),userId:r.toString(),keys:t,algorithms:Array.from(g),verified:o,signatures:s,displayName:e.displayName,dehydrated:e.isDehydrated})}function St(e){return new Map(Object.entries(e).map((e=>{var[r,t]=e;return[r,_t(t)]})))}function _t(e){var r,t=new Map(Object.entries(e.keys)),n=null===(r=e.unsigned)||void 0===r?void 0:r.device_display_name,i=new Map;if(e.signatures)for(var o in e.signatures)i.set(o,new Map(Object.entries(e.signatures[o])));return new lr({deviceId:e.device_id,userId:e.user_id,keys:t,algorithms:e.algorithms,verified:ie.Unverified,signatures:i,displayName:n})}class bt{constructor(e,r,t){this.olmMachine=e,this.outgoingRequestProcessor=r,this.secretStorage=t}bootstrapCrossSigning(e){var r=this;return c((function*(){if(e.setupNewCrossSigning)yield r.resetCrossSigning(e.authUploadDeviceSigningKeys);else{var t=yield r.olmMachine.crossSigningStatus(),n=yield r.secretStorage.get("m.cross_signing.master"),i=yield r.secretStorage.get("m.cross_signing.self_signing"),o=yield r.secretStorage.get("m.cross_signing.user_signing"),s=!!(n&&i&&o),a=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(g.log("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:s}),a)(yield r.secretStorage.hasKey())?s?g.log("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(g.log("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),yield r.exportCrossSigningKeysToStorage()):g.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(s){g.log("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally");var c=yield r.olmMachine.importCrossSigningKeys(n,i,o);if(!c.hasMaster||!c.hasSelfSigning||!c.hasUserSigning)throw new Error("importCrossSigningKeys failed to import the keys");var u=yield r.olmMachine.getDevice(r.olmMachine.userId,r.olmMachine.deviceId);try{var d=yield u.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(d)}finally{u.free()}}else g.log("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),yield r.resetCrossSigning(e.authUploadDeviceSigningKeys);g.log("bootstrapCrossSigning: complete")}}))()}resetCrossSigning(e){var r=this;return c((function*(){var t=yield r.olmMachine.bootstrapCrossSigning(!0);for(var n of((yield r.secretStorage.hasKey())?(g.log("resetCrossSigning: exporting private keys to secret storage"),yield r.exportCrossSigningKeysToStorage()):g.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),g.log("resetCrossSigning: publishing public keys to server"),[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest]))n&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(n,e))}))()}exportCrossSigningKeysToStorage(){var e=this;return c((function*(){var r=yield e.olmMachine.exportCrossSigningKeys();null!=r&&r.masterKey?yield e.secretStorage.store("m.cross_signing.master",r.masterKey):g.error("Cannot export MSK to secret storage, private key unknown"),null!=r&&r.self_signing_key?yield e.secretStorage.store("m.cross_signing.self_signing",r.self_signing_key):g.error("Cannot export SSK to secret storage, private key unknown"),null!=r&&r.userSigningKey?yield e.secretStorage.store("m.cross_signing.user_signing",r.userSigningKey):g.error("Cannot export USK to secret storage, private key unknown")}))()}}function Xe(e){return ke.apply(this,arguments)}function ke(){return(ke=c((function*(e){return br(e,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}))).apply(this,arguments)}function br(e,r){return Se.apply(this,arguments)}function Se(){return(Se=c((function*(e,r){var t=yield e.getDefaultKeyId();if(!t)return!1;for(var n of r){if(!(t in((yield e.isStored(n))||{})))return!1}return!0}))).apply(this,arguments)}var E=function(e){return e.Sas="m.sas.v1",e.ShowQrCode="m.qr_code.show.v1",e.ScanQrCode="m.qr_code.scan.v1",e.Reciprocate="m.reciprocate.v1",e}({});class N extends H{constructor(e,r,t,n){super(),this.olmMachine=e,this.inner=r,this.outgoingRequestProcessor=t,this.supportedVerificationMethods=n,y(this,"reEmitter",void 0),y(this,"_accepting",!1),y(this,"_cancelling",!1),y(this,"_verifier",void 0),this.reEmitter=new gr(this);var i=new WeakRef(this);r.registerChangesCallback(c((function*(){var e;return null===(e=i.deref())||void 0===e?void 0:e.onChange()})))}onChange(){var e=this.inner.getVerification();e instanceof Ge?void 0===this._verifier||this._verifier instanceof er?this.setVerifier(new rr(e,this,this.outgoingRequestProcessor)):this._verifier instanceof rr&&this._verifier.replaceInner(e):e instanceof We&&void 0===this._verifier&&this.setVerifier(new er(e,this.outgoingRequestProcessor)),this.emit(j.Change)}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[j.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[j.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return null===(e=this.inner.roomId)||void 0===e?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return null===(e=this.inner.otherDeviceId)||void 0===e?void 0:e.toString()}getOtherDevice(){var e=this;return c((function*(){var r=e.inner.otherDeviceId;if(r)return yield e.olmMachine.getDevice(e.inner.otherUserId,r,5)}))()}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){var e=this.inner.phase();switch(e){case B.Created:case B.Requested:return S.Requested;case B.Ready:return this._accepting?S.Requested:S.Ready;case B.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case B.Done:return S.Done;case B.Cancelled:return S.Cancelled}throw new Error("Unknown verification phase ".concat(e))}get pending(){if(this.inner.isPassive())return!1;var e=this.phase;return e!==S.Done&&e!==S.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==S.Started)return null;var e=this.inner.getVerification();return e instanceof Ge?E.Sas:e instanceof We?E.Reciprocate:null}otherPartySupportsMethod(e){var r=this.inner.theirSupportedMethods;if(void 0===r)return!1;var t=Rr[e];return r.some((e=>e===t))}accept(){var e=this;return c((function*(){if(e.inner.phase()!==B.Requested||e._accepting)throw new Error("Cannot accept a verification request in phase ".concat(e.phase));e._accepting=!0;try{var r=e.inner.acceptWithMethods(e.supportedVerificationMethods.map(se));r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))}finally{e._accepting=!1}e.emit(j.Change)}))()}cancel(e){var r=this;return c((function*(){if(!r._cancelling){r._cancelling=!0;try{var e=r.inner.cancel();e&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(e))}finally{r._cancelling=!1}}}))()}beginKeyVerification(e,r){throw new Error("not implemented")}startVerification(e){var r=this;return c((function*(){if(e!==E.Sas)throw new Error("Unsupported verification method ".concat(e));if(!(yield r.getOtherDevice()))throw new Error("startVerification(): other device is unknown");var t=yield r.inner.startSas();if(t){var[,n]=t;yield r.outgoingRequestProcessor.makeOutgoingRequest(n)}if(!r._verifier)throw new Error("Still no verifier after startSas() call");return r._verifier}))()}scanQRCode(e){var r=this;return c((function*(){var t=$r.fromBytes(e),n=yield r.inner.scanQrCode(t);if(!r._verifier)throw new Error("Still no verifier after scanQrCode() call");var i=n.reciprocate();return i&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(i)),r._verifier}))()}get verifier(){return this.phase===S.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}generateQRCode(){var e=this;return c((function*(){if(!(yield e.getOtherDevice()))throw new Error("generateQRCode(): other device is unknown");var r=yield e.inner.generateQrCode();if(r)return r.toBytes()}))()}get cancellationCode(){var e,r;return null!==(e=null===(r=this.inner.cancelInfo)||void 0===r?void 0:r.cancelCode())&&void 0!==e?e:null}get cancellingUserId(){var e=this.inner.cancelInfo;if(e)return e.cancelledbyUs()?this.olmMachine.userId.toString():this.inner.otherUserId.toString()}}class wr extends H{constructor(e,r){super(),this.inner=e,this.outgoingRequestProcessor=r,y(this,"completionDeferred",void 0),this.completionDeferred=hr();var t=new WeakRef(this);e.registerChangesCallback(c((function*(){var e;return null===(e=t.deref())||void 0===e?void 0:e.onChange()}))),this.completionDeferred.promise.catch((()=>null))}onChange(){if(this.inner.isDone())this.completionDeferred.resolve(void 0);else if(this.inner.isCancelled()){var e=this.inner.cancelInfo();this.completionDeferred.reject(new Error("Verification cancelled by ".concat(e.cancelledbyUs()?"us":"them"," with code ").concat(e.cancelCode(),": ").concat(e.reason())))}this.emit(j.Change)}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){var r=this.inner.cancel();r&&this.outgoingRequestProcessor.makeOutgoingRequest(r)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class er extends wr{constructor(e,r){super(e,r),y(this,"callbacks",null)}onChange(){null===this.callbacks&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>{this.confirmScanning()},cancel:()=>this.cancel()}),super.onChange()}verify(){var e=this;return c((function*(){null!==e.callbacks&&e.emit(Sr.ShowReciprocateQr,e.callbacks),yield e.completionDeferred.promise}))()}get verificationPhase(){switch(this.inner.state()){case U.Created:return S.Ready;case U.Scanned:case U.Confirmed:case U.Reciprocated:return S.Started;case U.Done:return S.Done;case U.Cancelled:return S.Cancelled;default:throw new Error("Unknown qr code state ".concat(this.inner.state()))}}getReciprocateQrCodeCallbacks(){return this.callbacks}confirmScanning(){var e=this;return c((function*(){var r=e.inner.confirmScanning();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))}))()}}class rr extends wr{constructor(e,r,t){super(e,t),y(this,"callbacks",null)}verify(){var e=this;return c((function*(){yield e.sendAccept(),yield e.completionDeferred.promise}))()}sendAccept(){var e=this;return c((function*(){var r=e.inner.accept();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))}))()}onChange(){var e,r=this;if(super.onChange(),null===this.callbacks){var t=this.inner.emoji(),n=this.inner.decimals();if(void 0===t&&void 0===n)return;var i={};t&&(i.emoji=t.map((e=>[e.symbol,e.description]))),n&&(i.decimal=[n[0],n[1],n[2]]),this.callbacks={sas:i,confirm:(e=c((function*(){var e=yield r.inner.confirm();for(var t of e)yield r.outgoingRequestProcessor.makeOutgoingRequest(t)})),function(){return e.apply(this,arguments)}),mismatch:()=>{var e=this.inner.cancelWithCode("m.mismatched_sas");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)},cancel:()=>{var e=this.inner.cancelWithCode("m.user");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)}},this.emit(Sr.ShowSas,this.callbacks)}}get verificationPhase(){return S.Started}getShowSasCallbacks(){return this.callbacks}replaceInner(e){if(this.inner!=e){this.inner=e;var r=new WeakRef(this);e.registerChangesCallback(c((function*(){var e;return null===(e=r.deref())||void 0===e?void 0:e.onChange()}))),this.sendAccept(),this.onChange()}}}var Rr={[E.Sas]:ee.SasV1,[E.ScanQrCode]:ee.QrCodeScanV1,[E.ShowQrCode]:ee.QrCodeShowV1,[E.Reciprocate]:ee.ReciprocateV1};function se(e){var r=Rr[e];if(void 0===r)throw new Error("Unknown verification method ".concat(e));return r}function wt(e){switch(e.getType()){case w.KeyVerificationCancel:case w.KeyVerificationDone:case w.KeyVerificationMac:case w.KeyVerificationStart:case w.KeyVerificationKey:case w.KeyVerificationReady:case w.KeyVerificationAccept:return!0;case w.RoomMessage:return e.getContent().msgtype===yr.KeyVerificationRequest;default:return!1}}class Rt extends H{constructor(e,r,t){super(),this.olmMachine=e,this.http=r,this.outgoingRequestProcessor=t,y(this,"checkedForBackup",!1),y(this,"serverBackupInfo",void 0),y(this,"activeBackupVersion",null),y(this,"stopped",!1),y(this,"backupKeysLoopRunning",!1),y(this,"keyBackupCheckInProgress",null)}stop(){this.stopped=!0}getActiveBackupVersion(){var e=this;return c((function*(){return(yield e.olmMachine.isBackupEnabled())?e.activeBackupVersion:null}))()}getServerBackupInfo(){var e=this;return c((function*(){return yield e.checkKeyBackupAndEnable(!1),e.serverBackupInfo}))()}isKeyBackupTrusted(e){var r=this;return c((function*(){var t=yield r.olmMachine.verifyBackup(e),n=yield r.olmMachine.getBackupKeys(),i=null==n?void 0:n.decryptionKey;return{matchesDecryptionKey:!!i&&tr(e,i),trusted:t.trusted()}}))()}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally((()=>{this.keyBackupCheckInProgress=null}))),this.keyBackupCheckInProgress)}handleBackupSecretReceived(e){var r=this;return c((function*(){var t,n;try{n=yield r.requestKeyBackupVersion()}catch(e){return g.warn("handleBackupSecretReceived: Error checking for latest key backup",e),!1}if(null===(t=n)||void 0===t||!t.version)return g.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup"),!1;try{var i=x.fromBase64(e);return tr(n,i)?(g.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),yield r.saveBackupDecryptionKey(i,n.version),!0):(g.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup."),!1)}catch(e){g.warn("handleBackupSecretReceived: Invalid backup decryption key",e)}return!1}))()}saveBackupDecryptionKey(e,r){var t=this;return c((function*(){yield t.olmMachine.saveBackupDecryptionKey(e,r),t.emit(f.KeyBackupDecryptionKeyCached,r)}))()}importRoomKeys(e,r){var t=this;return c((function*(){yield t.importRoomKeysAsJson(JSON.stringify(e),r)}))()}importRoomKeysAsJson(e,r){var t=this;return c((function*(){yield t.olmMachine.importExportedRoomKeys(e,((e,t)=>{var n,i={total:Number(t),successes:Number(e),stage:F.LoadKeys,failures:0};null==r||null===(n=r.progressCallback)||void 0===n||n.call(r,i)}))}))()}importBackedUpRoomKeys(e,r,t){var n=this;return c((function*(){var i=new Map;for(var o of e){var s=new R(o.room_id);i.has(s)||i.set(s,new Map),i.get(s).set(o.session_id,o)}yield n.olmMachine.importBackedUpRoomKeys(i,((e,r,n)=>{var i,o={total:Number(r),successes:Number(e),stage:F.LoadKeys,failures:Number(n)};null==t||null===(i=t.progressCallback)||void 0===i||i.call(t,o)}),r)}))()}doCheckKeyBackup(){var e=this;return c((function*(){var r;g.log("Checking key backup status...");try{r=yield e.requestKeyBackupVersion()}catch(r){return g.warn("Error checking for active key backup",r),e.serverBackupInfo=void 0,null}e.checkedForBackup=!0,r&&!r.version&&(g.warn("active backup lacks a useful 'version'; ignoring it"),r=void 0),e.serverBackupInfo=r;var t=yield e.getActiveBackupVersion();if(!r)return null!==t?(g.log("No key backup present on server: disabling key backup"),yield e.disableKeyBackup()):g.log("No key backup present on server: not enabling key backup"),null;var n=yield e.isKeyBackupTrusted(r);return n.matchesDecryptionKey||n.trusted?null===t?(g.log("Found usable key backup v".concat(r.version,": enabling key backups")),yield e.enableKeyBackup(r)):t!==r.version?(g.log("On backup version ".concat(t," but found version ").concat(r.version,": switching.")),yield e.disableKeyBackup(),yield e.enableKeyBackup(r)):g.log("Backup version ".concat(r.version," still current")):null!==t?(g.log("Key backup present on server but not trusted: disabling key backup"),yield e.disableKeyBackup()):g.log("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:r,trustInfo:n}}))()}enableKeyBackup(e){var r=this;return c((function*(){yield r.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),r.activeBackupVersion=e.version,r.emit(f.KeyBackupStatus,!0),r.backupKeysLoop()}))()}maybeUploadKey(){var e=this;return c((function*(){null!=e.activeBackupVersion&&e.backupKeysLoop()}))()}disableKeyBackup(){var e=this;return c((function*(){yield e.olmMachine.disableBackup(),e.activeBackupVersion=null,e.emit(f.KeyBackupStatus,!1)}))()}backupKeysLoop(){var e=arguments,r=this;return c((function*(){var t=e.length>0&&void 0!==e[0]?e[0]:1e4;if(r.backupKeysLoopRunning)g.log("Backup loop already running");else{r.backupKeysLoopRunning=!0,g.log("Backup: Starting keys upload loop for backup version:".concat(r.activeBackupVersion,"."));var n=Math.random()*t;yield T(n);try{for(var i=0,o=null,s=!0;!r.stopped;){var a=void 0;try{a=yield M(g,"BackupRoomKeys: Get keys to backup from rust crypto-sdk",c((function*(){return yield r.olmMachine.backupRoomKeys()})))}catch(e){g.error("Backup: Failed to get keys to backup from rust crypto-sdk",e)}if(!a||r.stopped||!r.activeBackupVersion)return g.log("Backup: Ending loop for version ".concat(r.activeBackupVersion,".")),void(a||r.emit(f.KeyBackupSessionsRemaining,0));try{if(yield r.outgoingRequestProcessor.makeOutgoingRequest(a),i=0,r.stopped)break;if(!s&&null===o)try{var u=yield r.olmMachine.roomKeyCounts();o=u.total-u.backedUp}catch(e){g.error("Backup: Failed to get key counts from rust crypto-sdk",e)}if(null!==o){r.emit(f.KeyBackupSessionsRemaining,o);var d=r.keysCountInBatch(a);o=Math.max(o-d,0)}}catch(e){if(i++,g.error("Backup: Error processing backup request for rust crypto-sdk",e),e instanceof pr){var l=e.data.errcode;if("M_NOT_FOUND"==l||"M_WRONG_ROOM_KEYS_VERSION"==l){g.log("Backup: Failed to upload keys to current vesion: ".concat(l,"."));try{yield r.disableKeyBackup()}catch(e){g.error("Backup: An error occurred while disabling key backup:",e)}return r.emit(f.KeyBackupFailed,e.data.errcode),r.backupKeysLoopRunning=!1,void r.checkKeyBackupAndEnable(!0)}if(e.isRateLimitError())try{var y=e.getRetryAfterMs();if(y&&y>0){yield T(y);continue}}catch(e){g.warn("Backup: An error occurred while retrieving a rate-limit retry delay",e)}}yield T(1e3*Math.pow(2,Math.min(i-1,4)))}s=!1}}finally{r.backupKeysLoopRunning=!1}}}))()}keysCountInBatch(e){return ir(JSON.parse(e.body))}requestKeyBackupVersion(e){var r=this;return c((function*(){return yield Kr(r.http,e)}))()}setupKeyBackup(e){var r=this;return c((function*(){yield r.deleteAllKeyBackupVersions();var t=x.createRandomKey(),n=t.megolmV1PublicKey,i={public_key:n.publicKeyBase64};yield e(i);var o=yield r.http.authedRequest(k.Post,"/room_keys/version",void 0,{algorithm:n.algorithm,auth_data:i},{prefix:W.V3});return yield r.saveBackupDecryptionKey(t,o.version),{version:o.version,algorithm:n.algorithm,authData:i,decryptionKey:t}}))()}deleteAllKeyBackupVersions(){var e=this;return c((function*(){for(var r,t,n=null!==(r=null===(t=yield e.requestKeyBackupVersion())||void 0===t?void 0:t.version)&&void 0!==r?r:null;null!=n;){var i,o;yield e.deleteKeyBackupVersion(n),n=null!==(i=null===(o=yield e.requestKeyBackupVersion())||void 0===o?void 0:o.version)&&void 0!==i?i:null}}))()}deleteKeyBackupVersion(e){var r=this;return c((function*(){g.debug("deleteKeyBackupVersion v:".concat(e));var t=ce("/room_keys/version/$version",{$version:e});yield r.http.authedRequest(k.Delete,t,void 0,void 0,{prefix:W.V3}),r.activeBackupVersion===e&&(r.serverBackupInfo=null,yield r.disableKeyBackup())}))()}createBackupDecryptor(e){return new Kt(e)}restoreKeyBackup(e,r,t){var n=this;return c((function*(){var i=yield n.downloadKeyBackup(e);return n.importKeyBackup(i,e,r,t)}))()}downloadKeyBackup(e){return this.http.authedRequest(k.Get,"/room_keys/keys",{version:e},void 0,{prefix:W.V3})}importKeyBackup(e,r,t,n){var i=this;return c((function*(){var o,s=ir(e),a=0,u=0;null==n||null===(o=n.progressCallback)||void 0===o||o.call(n,{total:s,successes:a,stage:F.LoadKeys,failures:u});var d,l=(d=c((function*(e){var o,c=[],d=function*(r){(yield t.decryptSessions(e.get(r))).forEach((e=>{e.room_id=r,c.push(e)}))};for(var l of e.keys())yield*d(l);try{yield i.importBackedUpRoomKeys(c,r),a+=c.length}catch(e){u+=c.length,g.error("Error importing keys from backup",e)}null==n||null===(o=n.progressCallback)||void 0===o||o.call(n,{total:s,successes:a,stage:F.LoadKeys,failures:u})})),function(e){return d.apply(this,arguments)}),y=0,h=new Map;for(var[p,v]of Object.entries(e.rooms))if(v.sessions)for(var[f,m]of(h.set(p,{}),Object.entries(v.sessions))){h.get(p)[f]=m,(y+=1)>=200&&(yield l(h),(h=new Map).set(p,{}),y=0)}return y>0&&(yield l(h)),{total:s,imported:a}}))()}}function tr(e,r){var t;return"m.megolm_backup.v1.curve25519-aes-sha2"!==e.algorithm?(g.warn("backupMatchesPrivateKey: Unsupported backup algorithm",e.algorithm),!1):(null===(t=e.auth_data)||void 0===t?void 0:t.public_key)===r.megolmV1PublicKey.publicKeyBase64}class Kt{constructor(e){y(this,"decryptionKey",void 0),y(this,"sourceTrusted",void 0),this.decryptionKey=e,this.sourceTrusted=!1}decryptSessions(e){var r=this;return c((function*(){var t=[];for(var[n,i]of Object.entries(e))try{var o=JSON.parse(r.decryptionKey.decryptV1(i.session_data.ephemeral,i.session_data.mac,i.session_data.ciphertext));o.session_id=n,t.push(o)}catch(e){g.log("Failed to decrypt megolm session from backup",e,i)}return t}))()}free(){this.decryptionKey.free()}}function Kr(e,r){return _e.apply(this,arguments)}function _e(){return(_e=c((function*(e,r){try{var t=r?ce("/room_keys/version/$version",{$version:r}):"/room_keys/version";return yield e.authedRequest(k.Get,t,void 0,void 0,{prefix:W.V3})}catch(e){if("M_NOT_FOUND"===e.errcode)return null;throw e}}))).apply(this,arguments)}function pe(e,r){return r.auth_data.public_key===e.megolmV1PublicKey.publicKeyBase64}function ir(e){var r=0;for(var{sessions:t}of Object.values(e.rooms))r+=Object.keys(t).length;return r}class Et{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.outgoingRequestProcessor=t,y(this,"stopped",!1),y(this,"outgoingRequestLoopRunning",!1),y(this,"nextLoopDeferred",void 0)}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=hr());var e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch((e=>{this.logger.error("Uncaught error in outgoing request loop",e)})),e}outgoingRequestLoop(){var e=this;return c((function*(){if(e.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");e.outgoingRequestLoopRunning=!0;try{for(;!e.stopped&&e.nextLoopDeferred;){var r=e.nextLoopDeferred;e.nextLoopDeferred=void 0,yield e.processOutgoingRequests().then(r.resolve,r.reject)}}finally{e.outgoingRequestLoopRunning=!1}e.nextLoopDeferred&&e.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))}))()}processOutgoingRequests(){var e=this;return c((function*(){if(!e.stopped){var r,t=yield e.olmMachine.outgoingRequests(),n=function*(r){if(e.stopped)return{v:void 0};try{yield M(e.logger,"Make outgoing request ".concat(r.type),c((function*(){yield e.outgoingRequestProcessor.makeOutgoingRequest(r)})))}catch(t){e.logger.error("Failed to process outgoing request ".concat(r.type,": ").concat(t))}};for(var i of t)if(r=yield*n(i))return r.v}}))()}}var re=5e3,D=function(e){return e.MISSING_DECRYPTION_KEY="MISSING_DECRYPTION_KEY",e.NETWORK_ERROR="NETWORK_ERROR",e.STOPPED="STOPPED",e}(D||{});class L extends Error{constructor(e){super("Failed to get key from backup: ".concat(e)),this.code=e,this.name="KeyDownloadError"}}class nr extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class Mt{constructor(e,r,t,n){this.olmMachine=r,this.http=t,this.backupManager=n,y(this,"stopped",!1),y(this,"configuration",null),y(this,"sessionLastCheckAttemptedTime",new Map),y(this,"logger",void 0),y(this,"downloadLoopRunning",!1),y(this,"queuedRequests",[]),y(this,"hasConfigurationProblem",!1),y(this,"currentBackupVersionCheck",null),y(this,"onBackupStatusChanged",(()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then((e=>{e&&this.downloadKeysLoop()}))})),this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),n.on(f.KeyBackupStatus,this.onBackupStatusChanged),n.on(f.KeyBackupFailed,this.onBackupStatusChanged),n.on(f.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isKeyBackupDownloadConfigured(){return null!==this.configuration}getServerBackupInfo(){var e=this;return c((function*(){return yield e.backupManager.getServerBackupInfo()}))()}onDecryptionKeyMissingError(e,r){this.isAlreadyInQueue(e,r)?this.logger.trace("Not checking key backup for session ".concat(r," as it is already queued")):this.wasRequestedRecently(r)?this.logger.trace("Not checking key backup for session ".concat(r," as it was already requested recently")):(this.queuedRequests.push({roomId:e,megolmSessionId:r}),this.downloadKeysLoop())}stop(){this.stopped=!0,this.backupManager.off(f.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(f.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(f.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,r){return this.queuedRequests.some((t=>t.roomId==e&&t.megolmSessionId==r))}markAsNotFoundInBackup(e){var r=Date.now();this.sessionLastCheckAttemptedTime.set(e,r),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter(((e,t)=>Math.max(r-t,0)<re))))}wasRequestedRecently(e){var r=this.sessionLastCheckAttemptedTime.get(e);return!!r&&Math.max(Date.now()-r,0)<re}getBackupDecryptionKey(){var e=this;return c((function*(){try{return yield e.olmMachine.getBackupKeys()}catch{return null}}))()}requestRoomKeyFromBackup(e,r,t){var n=this;return c((function*(){var i=ce("/room_keys/keys/$roomId/$sessionId",{$roomId:r,$sessionId:t});return yield n.http.authedRequest(k.Get,i,{version:e},void 0,{prefix:W.V3})}))()}downloadKeysLoop(){var e=this;return c((function*(){if(!e.downloadLoopRunning&&!e.hasConfigurationProblem){e.downloadLoopRunning=!0;try{for(;e.queuedRequests.length>0;){var r=e.queuedRequests[0];try{var t=yield e.getOrCreateBackupConfiguration();if(!t)return void(e.downloadLoopRunning=!1);var n=yield e.queryKeyBackup(r.roomId,r.megolmSessionId,t);if(e.stopped)return;try{yield e.decryptAndImport(r,n,t)}catch(t){e.logger.error("Error while decrypting and importing key backup for session ".concat(r.megolmSessionId),t)}e.queuedRequests.shift()}catch(t){if(t instanceof L)switch(t.code){case D.MISSING_DECRYPTION_KEY:e.markAsNotFoundInBackup(r.megolmSessionId),e.queuedRequests.shift();break;case D.NETWORK_ERROR:yield T(re);break;case D.STOPPED:return void(e.downloadLoopRunning=!1)}else t instanceof nr&&(yield T(t.retryMillis))}}}finally{e.downloadLoopRunning=!1}}}))()}queryKeyBackup(e,r,t){var n=this;return c((function*(){if(n.logger.debug("Checking key backup for session ".concat(r)),n.stopped)throw new L(D.STOPPED);try{var i=yield n.requestRoomKeyFromBackup(t.backupVersion,e,r);return n.logger.debug("Got key from backup for sessionId:".concat(r)),i}catch(e){if(n.stopped)throw new L(D.STOPPED);if(n.logger.info("No luck requesting key backup for session ".concat(r,": ").concat(e)),e instanceof pr){if("M_NOT_FOUND"==e.data.errcode)throw new L(D.MISSING_DECRYPTION_KEY);if(e.isRateLimitError()){var o;try{var s;o=null!==(s=e.getRetryAfterMs())&&void 0!==s?s:void 0}catch(e){n.logger.warn("Error while retrieving a rate-limit retry delay",e)}throw o&&o>0&&n.logger.info("Rate limited by server, waiting ".concat(o,"ms")),new nr(o??re)}}throw new L(D.NETWORK_ERROR)}}))()}decryptAndImport(e,r,t){var n=this;return c((function*(){var i={[e.megolmSessionId]:r},o=yield t.decryptor.decryptSessions(i);for(var s of o)s.room_id=e.roomId;yield n.backupManager.importBackedUpRoomKeys(o,t.backupVersion)}))()}getOrCreateBackupConfiguration(){var e=this;return c((function*(){if(e.configuration)return e.configuration;if(e.hasConfigurationProblem)return null;if(null!=e.currentBackupVersionCheck)return e.logger.debug("Already checking server version, use current promise"),yield e.currentBackupVersionCheck;e.currentBackupVersionCheck=e.internalCheckFromServer();try{return yield e.currentBackupVersionCheck}finally{e.currentBackupVersionCheck=null}}))()}internalCheckFromServer(){var e=this;return c((function*(){var r,t,n,i,o=null;try{o=yield e.backupManager.getServerBackupInfo()}catch(r){return e.logger.debug("Backup: error while checking server version: ".concat(r)),e.hasConfigurationProblem=!0,null}if(e.logger.debug("Got current backup version from server: ".concat(null===(r=o)||void 0===r?void 0:r.version)),"m.megolm_backup.v1.curve25519-aes-sha2"!=(null===(t=o)||void 0===t?void 0:t.algorithm))return e.logger.info("Unsupported algorithm ".concat(null===(i=o)||void 0===i?void 0:i.algorithm)),e.hasConfigurationProblem=!0,null;if(null===(n=o)||void 0===n||!n.version)return e.logger.info("No current key backup"),e.hasConfigurationProblem=!0,null;var s=yield e.backupManager.getActiveBackupVersion();if(null==s||o.version!=s)return e.logger.info("The current backup version on the server (".concat(o.version,") is not trusted. Version we are currently backing up to: ").concat(s)),e.hasConfigurationProblem=!0,null;var a=yield e.getBackupDecryptionKey();if(null==a||!a.decryptionKey)return e.logger.debug("Not checking key backup for session (no decryption key)"),e.hasConfigurationProblem=!0,null;if(s!=a.backupVersion)return e.logger.debug("Version for which we have a decryption key (".concat(a.backupVersion,") doesn't match the version we are backing up to (").concat(s,")")),e.hasConfigurationProblem=!0,null;if(o.auth_data.public_key!=a.decryptionKey.megolmV1PublicKey.publicKeyBase64)return e.logger.debug("Key backup on server does not match our decryption key"),e.hasConfigurationProblem=!0,null;var c=e.backupManager.createBackupDecryptor(a.decryptionKey);return e.hasConfigurationProblem=!1,e.configuration={decryptor:c,backupVersion:s},e.configuration}))()}}function It(e,r){if(!e.private_key_salt||!e.private_key_iterations)throw new Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");return _r(r,e.private_key_salt,e.private_key_iterations,e.private_key_bits)}function sr(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function or(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?sr(Object(t),!0).forEach((function(r){y(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):sr(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}var ar=[E.Sas,E.ScanQrCode,E.ShowQrCode,E.Reciprocate];class Ct extends H{constructor(e,r,t,n,i,o,s){super(),this.logger=e,this.olmMachine=r,this.http=t,this.userId=n,this.secretStorage=o,this.cryptoCallbacks=s,y(this,"RECOVERY_KEY_DERIVATION_ITERATIONS",5e5),y(this,"_trustCrossSignedDevices",!0),y(this,"deviceIsolationMode",new Ur(!1)),y(this,"stopped",!1),y(this,"roomEncryptors",{}),y(this,"eventDecryptor",void 0),y(this,"keyClaimManager",void 0),y(this,"outgoingRequestProcessor",void 0),y(this,"crossSigningIdentity",void 0),y(this,"backupManager",void 0),y(this,"outgoingRequestsManager",void 0),y(this,"perSessionBackupDownloader",void 0),y(this,"dehydratedDeviceManager",void 0),y(this,"reemitter",new gr(this)),y(this,"globalBlacklistUnverifiedDevices",!1),y(this,"_supportedVerificationMethods",ar),this.outgoingRequestProcessor=new vt(r,t),this.outgoingRequestsManager=new Et(this.logger,r,this.outgoingRequestProcessor),this.keyClaimManager=new mt(r,this.outgoingRequestProcessor),this.backupManager=new Rt(r,t,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new Mt(this.logger,this.olmMachine,this.http,this.backupManager),this.dehydratedDeviceManager=new pt(this.logger,r,t,this.outgoingRequestProcessor,o),this.eventDecryptor=new Dt(this.logger,r,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[f.KeyBackupStatus,f.KeyBackupSessionsRemaining,f.KeyBackupFailed,f.KeyBackupDecryptionKeyCached]),this.reemitter.reEmit(this.dehydratedDeviceManager,[f.DehydratedDeviceCreated,f.DehydratedDeviceUploaded,f.RehydrationStarted,f.RehydrationProgress,f.RehydrationCompleted,f.RehydrationError,f.DehydrationKeyCached,f.DehydratedDeviceRotationError]),this.crossSigningIdentity=new bt(r,this.outgoingRequestProcessor,o),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new Vr;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.dehydratedDeviceManager.stop(),this.olmMachine.close())}encryptEvent(e,r){var t=this;return c((function*(){var r=e.getRoomId(),n=t.roomEncryptors[r];if(!n)throw new Error("Cannot encrypt event in unconfigured room ".concat(r));yield n.encryptEvent(e,t.globalBlacklistUnverifiedDevices,t.deviceIsolationMode)}))()}decryptEvent(e){var r=this;return c((function*(){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return yield r.eventDecryptor.attemptEventDecryption(e,r.deviceIsolationMode)}))()}getBackupDecryptor(e,r){var t=this;return c((function*(){if(!(r instanceof Uint8Array))throw new Error("getBackupDecryptor: expects Uint8Array");if("m.megolm_backup.v1.curve25519-aes-sha2"!=e.algorithm)throw new Error("getBackupDecryptor: Unsupported algorithm ".concat(e.algorithm));var n=x.fromBase64(ve(r));if(!pe(n,e))throw new Error("getBackupDecryptor: key backup on server does not match the decryption key");return t.backupManager.createBackupDecryptor(n)}))()}importBackedUpRoomKeys(e,r,t){var n=this;return c((function*(){return yield n.backupManager.importBackedUpRoomKeys(e,r,t)}))()}getVersion(){var e=zr();return"Rust SDK ".concat(e.matrix_sdk_crypto," (").concat(e.git_sha,"), Vodozemac ").concat(e.vodozemac)}setDeviceIsolationMode(e){this.deviceIsolationMode=e}isEncryptionEnabledInRoom(e){var r=this;return c((function*(){var t=yield r.olmMachine.getRoomSettings(new R(e));return!(null==t||!t.algorithm)}))()}getOwnDeviceKeys(){var e=this;return c((function*(){var r=e.olmMachine.identityKeys;return{ed25519:r.ed25519.toBase64(),curve25519:r.curve25519.toBase64()}}))()}prepareToEncrypt(e){var r=this.roomEncryptors[e.roomId];r&&r.prepareForEncryption(this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}forceDiscardSession(e){var r;return null===(r=this.roomEncryptors[e])||void 0===r?void 0:r.forceDiscardSession()}exportRoomKeys(){var e=this;return c((function*(){var r=yield e.olmMachine.exportRoomKeys((()=>!0));return JSON.parse(r)}))()}exportRoomKeysAsJson(){var e=this;return c((function*(){return yield e.olmMachine.exportRoomKeys((()=>!0))}))()}importRoomKeys(e,r){var t=this;return c((function*(){return yield t.backupManager.importRoomKeys(e,r)}))()}importRoomKeysAsJson(e,r){var t=this;return c((function*(){return yield t.backupManager.importRoomKeysAsJson(e,r)}))()}userHasCrossSigningKeys(){var e=arguments,r=this;return c((function*(){var t,n=e.length>0&&void 0!==e[0]?e[0]:r.userId,i=e.length>1&&void 0!==e[1]&&e[1],o=yield r.olmMachine.trackedUsers();for(var s of o)if(n===s.toString()){t=s;break}if(void 0!==t){if(n===r.userId){var a=r.olmMachine.queryKeysForUsers([t.clone()]);yield r.outgoingRequestProcessor.makeOutgoingRequest(a)}var c=yield r.olmMachine.getIdentity(t);return null==c||c.free(),void 0!==c}if(i){var u,d=null===(u=(yield r.downloadDeviceList(new Set([n]))).master_keys)||void 0===u?void 0:u[n];return!!d&&!!Object.values(d.keys)[0]}return!1}))()}getUserDeviceInfo(e){var r=arguments,t=this;return c((function*(){var n=r.length>1&&void 0!==r[1]&&r[1],i=new Map,o=yield t.getOlmMachineOrThrow().trackedUsers(),s=new Set;o.forEach((e=>s.add(e.toString())));var a=new Set;for(var c of e)s.has(c)?i.set(c,yield t.getUserDevices(c)):a.add(c);if(n&&a.size>=1){var u=yield t.downloadDeviceList(a);Object.entries(u.device_keys).forEach((e=>{var[r,t]=e;return i.set(r,St(t))}))}return i}))()}getUserDevices(e){var r=this;return c((function*(){var t=new m(e),n=yield r.olmMachine.getUserDevices(t,1);try{var i=n.devices();try{return new Map(i.map((e=>[e.deviceId.toString(),kt(e,t)])))}finally{i.forEach((e=>e.free()))}}finally{n.free()}}))()}downloadDeviceList(e){var r=this;return c((function*(){var t={device_keys:{}};return e.forEach((e=>t.device_keys[e]=[])),yield r.http.authedRequest(k.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})}))()}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}setDeviceVerified(e,r){var t=arguments,n=this;return c((function*(){var i=!(t.length>2&&void 0!==t[2])||t[2],o=yield n.olmMachine.getDevice(new m(e),new O(r));if(!o)throw new Error("Unknown device ".concat(e,"|").concat(r));try{yield o.setLocalTrust(i?Je.Verified:Je.Unset)}finally{o.free()}}))()}crossSignDevice(e){var r=this;return c((function*(){var t=yield r.olmMachine.getDevice(new m(r.userId),new O(e));if(!t)throw new Error("Unknown device ".concat(e));try{var n=yield t.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(n)}finally{t.free()}}))()}getDeviceVerificationStatus(e,r){var t=this;return c((function*(){var n=yield t.olmMachine.getDevice(new m(e),new O(r));if(!n)return null;try{return new Nr({signedByOwner:n.isCrossSignedByOwner(),crossSigningVerified:n.isCrossSigningTrusted(),localVerified:n.isLocallyTrusted(),trustCrossSignedDevices:t._trustCrossSignedDevices})}finally{n.free()}}))()}getUserVerificationStatus(e){var r=this;return c((function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(void 0===t)return new Ne(!1,!1,!1);var n=t.isVerified(),i=t.wasPreviouslyVerified(),o=t instanceof Zr&&t.identityNeedsUserApproval();return t.free(),new Ne(n,i,!1,o)}))()}pinCurrentUserIdentity(e){var r=this;return c((function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(void 0===t)throw new Error("Cannot pin identity of unknown user");if(t instanceof Xr)throw new Error("Cannot pin identity of own user");yield t.pinCurrentMasterKey()}))()}withdrawVerificationRequirement(e){var r=this;return c((function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(void 0===t)throw new Error("Cannot withdraw verification of unknown user");yield t.withdrawVerification()}))()}isCrossSigningReady(){var e=this;return c((function*(){var{privateKeysInSecretStorage:r,privateKeysCachedLocally:t}=yield e.getCrossSigningStatus(),n=!!t.masterKey&&!!t.selfSigningKey&&!!t.userSigningKey,i=yield e.getOwnIdentity();return!(null==i||!i.isVerified())&&(n||r)}))()}getCrossSigningKeyId(){var e=arguments,r=this;return c((function*(){var t=e.length>0&&void 0!==e[0]?e[0]:Z.Master,n=yield r.olmMachine.getIdentity(new m(r.userId));if(!n)return null;try{var i,o=yield r.olmMachine.crossSigningStatus();if(!(o.hasMaster&&o.hasUserSigning&&o.hasSelfSigning)||!n.isVerified())return null;switch(t){case Z.Master:i=n.masterKey;break;case Z.SelfSigning:i=n.selfSigningKey;break;case Z.UserSigning:i=n.userSigningKey;break;default:return null}var s=JSON.parse(i);return Object.values(s.keys)[0]}finally{n.free()}}))()}bootstrapCrossSigning(e){var r=this;return c((function*(){yield r.crossSigningIdentity.bootstrapCrossSigning(e)}))()}isSecretStorageReady(){var e=this;return c((function*(){var r=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];return null!=(yield e.backupManager.getActiveBackupVersion())&&r.push("m.megolm_backup.v1"),br(e.secretStorage,r)}))()}bootstrapSecretStorage(){var e=arguments,r=this;return c((function*(){var{createSecretStorageKey:t,setupNewSecretStorage:n,setupNewKeyBackup:i}=e.length>0&&void 0!==e[0]?e[0]:{},o=n||!(yield r.secretStorageHasAESKey());if(o){if(!t)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");r.logger.info("bootstrapSecretStorage: creating new secret storage key");var s=yield t();if(!s)throw new Error("createSecretStorageKey() callback did not return a secret storage key");yield r.addSecretStorageKeyToSecretStorage(s)}var a=yield r.olmMachine.exportCrossSigningKeys();a&&void 0!==a.masterKey&&void 0!==a.self_signing_key&&void 0!==a.userSigningKey&&(o||!(yield Xe(r.secretStorage)))&&(r.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now."),yield r.secretStorage.store("m.cross_signing.master",a.masterKey),yield r.secretStorage.store("m.cross_signing.user_signing",a.userSigningKey),yield r.secretStorage.store("m.cross_signing.self_signing",a.self_signing_key)),i?yield r.resetKeyBackup():yield r.saveBackupKeyToStorage()}))()}saveBackupKeyToStorage(){var e=this;return c((function*(){var r=yield e.backupManager.getServerBackupInfo();if(r&&r.version){var t=yield e.olmMachine.getBackupKeys();if(t.decryptionKey)if(pe(t.decryptionKey,r)){var n=t.decryptionKey.toBase64();yield e.secretStorage.store("m.megolm_backup.v1",n)}else g.info("Not saving backup key to secret storage: decryption key does not match backup info");else g.info("Not saving backup key to secret storage: no backup key")}else g.info("Not saving backup key to secret storage: no backup info")}))()}addSecretStorageKeyToSecretStorage(e){var r=this;return c((function*(){var t,n,i,o,s=yield r.secretStorage.addKey(xe,{passphrase:null===(t=e.keyInfo)||void 0===t?void 0:t.passphrase,name:null===(n=e.keyInfo)||void 0===n?void 0:n.name,key:e.privateKey});yield r.secretStorage.setDefaultKeyId(s.keyId),null===(i=(o=r.cryptoCallbacks).cacheSecretStorageKey)||void 0===i||i.call(o,s.keyId,s.keyInfo,e.privateKey)}))()}secretStorageHasAESKey(){var e=this;return c((function*(){var r=yield e.secretStorage.getKey();if(!r)return!1;var[,t]=r;return t.algorithm===xe}))()}getCrossSigningStatus(){var e=this;return c((function*(){var r=yield e.getOlmMachineOrThrow().getIdentity(new m(e.userId)),t=!(null==r||!r.masterKey||null==r||!r.selfSigningKey||null==r||!r.userSigningKey);null==r||r.free();var n=yield Xe(e.secretStorage),i=yield e.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:n,privateKeysCachedLocally:{masterKey:!(null==i||!i.hasMaster),userSigningKey:!(null==i||!i.hasUserSigning),selfSigningKey:!(null==i||!i.hasSelfSigning)}}}))()}createRecoveryKeyFromPassphrase(e){var r=this;return c((function*(){if(e){var t=Ae(32),n=yield _r(e,t,r.RECOVERY_KEY_DERIVATION_ITERATIONS);return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:r.RECOVERY_KEY_DERIVATION_ITERATIONS,salt:t}},privateKey:n,encodedPrivateKey:$e(n)}}var i=new Uint8Array(32);return globalThis.crypto.getRandomValues(i),{privateKey:i,encodedPrivateKey:$e(i)}}))()}getEncryptionInfoForEvent(e){var r=this;return c((function*(){return r.eventDecryptor.getEncryptionInfoForEvent(e)}))()}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new m(e)).filter((e=>void 0===e.roomId)).map((e=>new N(this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)))}findVerificationRequestDMInProgress(e,r){if(!r)throw new Error("missing userId");var t=this.olmMachine.getVerificationRequests(new m(r)).find((r=>{var t;return(null===(t=r.roomId)||void 0===t?void 0:t.toString())===e}));if(t)return new N(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)}requestVerificationDM(e,r){var t=this;return c((function*(){var n=yield t.olmMachine.getIdentity(new m(e));if(!n)throw new Error("unknown userId ".concat(e));try{var i=t._supportedVerificationMethods.map((e=>se(e))),o=yield n.verificationRequestContent(i),s=yield t.sendVerificationRequestContent(r,o),a=yield n.requestVerification(new R(r),new et(s),i);return new N(t.olmMachine,a,t.outgoingRequestProcessor,t._supportedVerificationMethods)}finally{n.free()}}))()}sendVerificationRequestContent(e,r){var t=this;return c((function*(){var n=Ae(32),{event_id:i}=yield t.http.authedRequest(k.Put,"/_matrix/client/v3/rooms/".concat(encodeURIComponent(e),"/send/m.room.message/").concat(encodeURIComponent(n)),void 0,r,{prefix:""});return i}))()}setSupportedVerificationMethods(e){this._supportedVerificationMethods=e??ar}requestOwnUserVerification(){var e=this;return c((function*(){var r=yield e.olmMachine.getIdentity(new m(e.userId));if(void 0===r)throw new Error("cannot request verification for this device when there is no existing cross-signing key");try{var[t,n]=yield r.requestVerification(e._supportedVerificationMethods.map(se));return yield e.outgoingRequestProcessor.makeOutgoingRequest(n),new N(e.olmMachine,t,e.outgoingRequestProcessor,e._supportedVerificationMethods)}finally{r.free()}}))()}requestDeviceVerification(e,r){var t=this;return c((function*(){var n=yield t.olmMachine.getDevice(new m(e),new O(r));if(!n)throw new Error("Not a known device");try{var[i,o]=n.requestVerification(t._supportedVerificationMethods.map(se));return yield t.outgoingRequestProcessor.makeOutgoingRequest(o),new N(t.olmMachine,i,t.outgoingRequestProcessor,t._supportedVerificationMethods)}finally{n.free()}}))()}getSessionBackupPrivateKey(){var e=this;return c((function*(){var r=yield e.olmMachine.getBackupKeys();return r.decryptionKey?fe(r.decryptionKey.toBase64()):null}))()}storeSessionBackupPrivateKey(e,r){var t=this;return c((function*(){var n=ve(e);if(!r)throw new Error("storeSessionBackupPrivateKey: version is required");yield t.backupManager.saveBackupDecryptionKey(x.fromBase64(n),r)}))()}loadSessionBackupPrivateKeyFromSecretStorage(){var e=this;return c((function*(){var r=yield e.secretStorage.get("m.megolm_backup.v1");if(!r)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage");var t=yield e.backupManager.getServerBackupInfo();if(!t||!t.version)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version");var n=x.fromBase64(r);if(!pe(n,t))throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info");yield e.backupManager.saveBackupDecryptionKey(n,t.version)}))()}getActiveSessionBackupVersion(){var e=this;return c((function*(){return yield e.backupManager.getActiveBackupVersion()}))()}getKeyBackupInfo(){var e=this;return c((function*(){return(yield e.backupManager.getServerBackupInfo())||null}))()}isKeyBackupTrusted(e){var r=this;return c((function*(){return yield r.backupManager.isKeyBackupTrusted(e)}))()}checkKeyBackupAndEnable(){var e=this;return c((function*(){return yield e.backupManager.checkKeyBackupAndEnable(!0)}))()}deleteKeyBackupVersion(e){var r=this;return c((function*(){yield r.backupManager.deleteKeyBackupVersion(e)}))()}resetKeyBackup(){var e=this;return c((function*(){var r=yield e.backupManager.setupKeyBackup((r=>e.signObject(r)));(yield e.secretStorageHasAESKey())&&(yield e.secretStorage.store("m.megolm_backup.v1",r.decryptionKey.toBase64())),e.checkKeyBackupAndEnable()}))()}disableKeyStorage(){var e=this;return c((function*(){var r=yield e.getKeyBackupInfo();null!=r&&r.version?yield e.deleteKeyBackupVersion(r.version):g.error("Can't delete key backup version: no version available"),yield e.deleteSecretStorage(),yield e.dehydratedDeviceManager.delete()}))()}signObject(e){var r=this;return c((function*(){var t=new Map(Object.entries(e.signatures||{})),n=e.unsigned;delete e.signatures,delete e.unsigned;var i=t.get(r.userId)||{},o=lt.stringify(e),s=yield r.olmMachine.sign(o),a=JSON.parse(s.asJSON());t.set(r.userId,or(or({},i),a[r.userId])),void 0!==n&&(e.unsigned=n),e.signatures=Object.fromEntries(t.entries())}))()}restoreKeyBackupWithPassphrase(e,r){var t=this;return c((function*(){var n=yield t.backupManager.getServerBackupInfo();if(null==n||!n.version)throw new Error("No backup info available");var i=yield It(n.auth_data,e);return yield t.storeSessionBackupPrivateKey(i,n.version),t.restoreKeyBackup(r)}))()}restoreKeyBackup(e){var r=this;return c((function*(){var t=yield r.olmMachine.getBackupKeys(),{decryptionKey:n,backupVersion:i}=t;if(!n||!i)throw new Error("No decryption key found in crypto store");var o=fe(n.toBase64()),s=yield r.backupManager.requestKeyBackupVersion(i);if(!s)throw new Error("Backup version to restore ".concat(i," not found on server"));var a=yield r.getBackupDecryptor(s,o);try{var c;return null==e||null===(c=e.progressCallback)||void 0===c||c.call(e,{stage:F.Fetch}),yield r.backupManager.restoreKeyBackup(i,a,e)}finally{a.free()}}))()}isDehydrationSupported(){var e=this;return c((function*(){return yield e.dehydratedDeviceManager.isSupported()}))()}startDehydration(){var e=arguments,r=this;return c((function*(){var t=e.length>0&&void 0!==e[0]?e[0]:{};if(!(yield r.isCrossSigningReady())||!(yield r.isSecretStorageReady()))throw new Error("Device dehydration requires cross-signing and secret storage to be set up");return yield r.dehydratedDeviceManager.start(t||{})}))()}importSecretsBundle(e){var r=this;return c((function*(){var t=rt.from_json(e);yield r.getOlmMachineOrThrow().importSecretsBundle(t)}))()}exportSecretsBundle(){var e=this;return c((function*(){var r=yield e.getOlmMachineOrThrow().exportSecretsBundle(),t=r.to_json();return r.free(),t}))()}encryptToDeviceMessages(e,r,t){var n=this;return c((function*(){var i=new dr(n.logger,"encryptToDeviceMessages"),o=new Set(r.map((e=>{var{userId:r}=e;return r})));yield n.keyClaimManager.ensureSessionsForUsers(i,Array.from(o).map((e=>new m(e))));var s,a={batch:[],eventType:w.RoomMessageEncrypted};return yield Promise.all(r.map((s=c((function*(r){var{userId:i,deviceId:o}=r,s=yield n.olmMachine.getDevice(new m(i),new O(o));if(s){var c=JSON.parse(yield s.encryptToDeviceEvent(e,t));a.batch.push({deviceId:o,userId:i,payload:c})}else n.logger.warn("encryptToDeviceMessages: unknown device ".concat(i,":").concat(o))})),function(e){return s.apply(this,arguments)}))),a}))()}resetEncryption(e){var r=this;return c((function*(){r.logger.debug("resetEncryption: resetting encryption"),r.dehydratedDeviceManager.delete(),yield r.backupManager.deleteAllKeyBackupVersions(),yield r.deleteSecretStorage(),yield r.crossSigningIdentity.bootstrapCrossSigning({setupNewCrossSigning:!0,authUploadDeviceSigningKeys:e}),yield r.resetKeyBackup(),r.logger.debug("resetEncryption: ended")}))()}deleteSecretStorage(){var e=this;return c((function*(){yield e.secretStorage.store("m.cross_signing.master",null),yield e.secretStorage.store("m.cross_signing.self_signing",null),yield e.secretStorage.store("m.cross_signing.user_signing",null),yield e.secretStorage.store("m.megolm_backup.v1",null);var r=yield e.secretStorage.getDefaultKeyId();r&&(yield e.secretStorage.store("m.secret_storage.key.".concat(r),null)),yield e.secretStorage.setDefaultKeyId(null)}))()}receiveSyncChanges(e){var r=this;return c((function*(){var{events:t,oneTimeKeysCounts:n=new Map,unusedFallbackKeys:i,devices:o=new He}=e,s=yield M(g,"receiveSyncChanges",c((function*(){return yield r.olmMachine.receiveSyncChanges(t?JSON.stringify(t):"[]",o,n,i)})));return JSON.parse(s)}))()}preprocessToDeviceMessages(e){var r=this;return c((function*(){var t=yield r.receiveSyncChanges({events:e});for(var n of t)if(n.type===w.KeyVerificationRequest){var i=n.sender,o=n.content.transaction_id;o&&i&&r.onIncomingKeyVerificationRequest(i,o)}return t}))()}processKeyCounts(e,r){var t=this;return c((function*(){var n=e&&new Map(Object.entries(e)),i=r&&new Set(r);(void 0!==n||void 0!==i)&&(yield t.receiveSyncChanges({oneTimeKeysCounts:n,unusedFallbackKeys:i}))}))()}processDeviceLists(e){var r=this;return c((function*(){var t,n,i=new He(null===(t=e.changed)||void 0===t?void 0:t.map((e=>new m(e))),null===(n=e.left)||void 0===n?void 0:n.map((e=>new m(e))));yield r.receiveSyncChanges({devices:i})}))()}onCryptoEvent(e,r){var t=this;return c((function*(){var n=r.getContent(),i=new fr;if("m.megolm.v1.aes-sha2"===n.algorithm){i.algorithm=J.MegolmV1AesSha2;try{i.sessionRotationPeriodMs=n.rotation_period_ms,i.sessionRotationPeriodMessages=n.rotation_period_msgs,yield t.olmMachine.setRoomSettings(new R(e.roomId),i)}catch(r){return void t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event which caused error: ").concat(r))}var o=t.roomEncryptors[e.roomId];o?o.onCryptoEvent(n):t.roomEncryptors[e.roomId]=new gt(t.olmMachine,t.keyClaimManager,t.outgoingRequestsManager,e,n)}else t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event with invalid algorithm ").concat(n.algorithm))}))()}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",e)}))}markAllTrackedUsersAsDirty(){var e=this;return c((function*(){yield e.olmMachine.markAllTrackedUsersAsDirty()}))()}onIncomingKeyVerificationRequest(e,r){var t=this.olmMachine.getVerificationRequest(new m(e),r);t?this.emit(f.VerificationRequestReceived,new N(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)):this.logger.info("Ignoring just-received verification request ".concat(r," which did not start a rust-side verification"))}onRoomMembership(e,r,t){var n=this.roomEncryptors[e.getRoomId()];n&&n.onRoomMembership(r)}onRoomKeysUpdated(e){var r=this;return c((function*(){for(var t of e)r.onRoomKeyUpdated(t);r.backupManager.maybeUploadKey()}))()}onRoomKeyUpdated(e){var r=this;if(!this.stopped){this.logger.debug("Got update for session ".concat(e.sessionId," from sender ").concat(e.senderKey.toBase64()," in ").concat(e.roomId.toString()));var t=this.eventDecryptor.getEventsPendingRoomKey(e.roomId.toString(),e.sessionId);if(0!==t.length){this.logger.debug("Retrying decryption on events:",t.map((e=>"".concat(e.getId()))));var n=function(e){e.attemptDecryption(r,{isRetry:!0}).catch((t=>{r.logger.info("Still unable to decrypt event ".concat(e.getId()," after receiving key"))}))};for(var i of t)n(i)}}}onRoomKeysWithheld(e){var r=this;return c((function*(){for(var t of e){r.logger.debug("Got withheld message for session ".concat(t.sessionId," in ").concat(t.roomId.toString()));var n=r.eventDecryptor.getEventsPendingRoomKey(t.roomId.toString(),t.sessionId);if(0===n.length)return;for(var i of(r.logger.debug("Retrying decryption on events:",n.map((e=>"".concat(e.getId())))),n))i.attemptDecryption(r,{isRetry:!0}).catch((e=>{}))}}))()}onUserIdentityUpdated(e){var r=this;return c((function*(){var t=yield r.getUserVerificationStatus(e.toString());r.emit(f.UserTrustStatusChanged,e.toString(),t),e.toString()===r.userId&&(r.emit(f.KeysChanged,{}),yield r.checkKeyBackupAndEnable())}))()}onDevicesUpdated(e){var r=this;return c((function*(){r.emit(f.WillUpdateDevices,e,!1),r.emit(f.DevicesUpdated,e,!1)}))()}handleSecretReceived(e,r){var t=this;return c((function*(){return t.logger.debug("onReceiveSecret: Received secret ".concat(e)),"m.megolm_backup.v1"===e&&(yield t.backupManager.handleBackupSecretReceived(r))}))()}checkSecrets(e){var r=this;return c((function*(){var t=yield r.olmMachine.getSecretsFromInbox(e);for(var n of t)if(yield r.handleSecretReceived(e,n))break;yield r.olmMachine.deleteSecretsFromInbox(e)}))()}onLiveEventFromSync(e){var r=this;return c((function*(){if(!e.isState()&&!e.getUnsigned().transaction_id){var t=(o=c((function*(t){wt(e)&&(yield r.onKeyVerificationEvent(t))})),function(e){return o.apply(this,arguments)});if(e.isDecryptionFailure()||e.isEncrypted()){var n=setTimeout((()=>e.off(de.Decrypted,i)),3e5),i=(r,o)=>{o||(clearTimeout(n),e.off(de.Decrypted,i),t(r))};e.on(de.Decrypted,i)}else yield t(e)}var o}))()}onKeyVerificationEvent(e){var r=this;return c((function*(){var t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");r.logger.debug("Incoming verification event ".concat(e.getId()," type ").concat(e.getType()," from ").concat(e.getSender())),yield r.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new R(t)),e.getType()===w.RoomMessage&&e.getContent().msgtype===yr.KeyVerificationRequest&&r.onIncomingKeyVerificationRequest(e.getSender(),e.getId()),r.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{r.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",e)}))}))()}getOwnIdentity(){var e=this;return c((function*(){return yield e.olmMachine.getIdentity(new m(e.userId))}))()}}class Dt{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.perSessionBackupDownloader=t,y(this,"eventsPendingKey",new Le((()=>new Le((()=>new Set)))))}attemptEventDecryption(e,r){var t=this;return c((function*(){var n;switch(t.addEventToPendingList(e),r.kind){case ae.AllDevicesIsolationMode:n=Ye.Untrusted;break;case ae.OnlySignedDevicesIsolationMode:n=Ye.CrossSignedOrLegacy}try{var i=yield t.olmMachine.decryptRoomEvent(cr(e),new R(e.getRoomId()),new tt(n));return t.removeEventFromPendingList(e),{clearEvent:JSON.parse(i.event),claimedEd25519Key:i.senderClaimedEd25519Key,senderCurve25519Key:i.senderCurve25519Key,forwardingCurve25519KeyChain:i.forwardingCurve25519KeyChain}}catch(r){if(!(r instanceof it))throw new b(_.UNKNOWN_ERROR,"Unknown error");t.onMegolmDecryptionError(e,r,yield t.perSessionBackupDownloader.getServerBackupInfo())}}))()}onMegolmDecryptionError(e,r,t){var n=e.getWireContent(),i={sender_key:n.sender_key,session_id:n.session_id};if(r.code===q.MissingRoomKey||r.code===q.UnknownMessageIndex){this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),n.session_id);var o=e.getMembershipAtEvent();if(o&&o!==oe.Join&&o!==oe.Invite)throw new b(_.HISTORICAL_MESSAGE_USER_NOT_JOINED,"This message was sent when we were not a member of the room.",i);if(e.getTs()<=this.olmMachine.deviceCreationTimeMs)throw null===t?new b(_.HISTORICAL_MESSAGE_NO_KEY_BACKUP,"This message was sent before this device logged in, and there is no key backup on the server.",i):this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()?new b(_.HISTORICAL_MESSAGE_WORKING_BACKUP,"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.",i):new b(_.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,"This message was sent before this device logged in, and key backup is not working.",i)}if(r.maybe_withheld){var s="The sender has disabled encrypting to unverified devices."===r.maybe_withheld?_.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE:_.MEGOLM_KEY_WITHHELD;throw new b(s,r.maybe_withheld,i)}switch(r.code){case q.MissingRoomKey:throw new b(_.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,"The sender's device has not sent us the keys for this message.",i);case q.UnknownMessageIndex:throw new b(_.OLM_UNKNOWN_MESSAGE_INDEX,"The sender's device has not sent us the keys for this message at this index.",i);case q.SenderIdentityVerificationViolation:throw this.removeEventFromPendingList(e),new b(_.SENDER_IDENTITY_PREVIOUSLY_VERIFIED,"The sender identity is unverified, but was previously verified.");case q.UnknownSenderDevice:throw this.removeEventFromPendingList(e),new b(_.UNKNOWN_SENDER_DEVICE,"The sender device is not known.");case q.UnsignedSenderDevice:throw this.removeEventFromPendingList(e),new b(_.UNSIGNED_SENDER_DEVICE,"The sender identity is not cross-signed.");default:throw new b(_.UNKNOWN_ERROR,r.description,i)}}getEncryptionInfoForEvent(e){var r=this;return c((function*(){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(null!==e.status)return{shieldColour:ne.NONE,shieldReason:null};var t=yield r.olmMachine.getRoomEventEncryptionInfo(cr(e),new R(e.getRoomId()));return Ot(r.logger,t)}))()}getEventsPendingRoomKey(e,r){var t=this.eventsPendingKey.get(e);if(!t)return[];var n=t.get(r);return n?[...n]:[]}addEventToPendingList(e){var r=e.getRoomId();r&&this.eventsPendingKey.getOrCreate(r).getOrCreate(e.getWireContent().session_id).add(e)}removeEventFromPendingList(e){var r=e.getRoomId();if(r){var t=this.eventsPendingKey.getOrCreate(r);if(t){var n=t.get(e.getWireContent().session_id);n&&(n.delete(e),0===n.size&&(t.delete(e.getWireContent().session_id),0===t.size&&this.eventsPendingKey.delete(r)))}}}}function cr(e){return JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()})}function Ot(e,r){if(void 0===r)return null;var t,n,i=r.shieldState(!1);switch(i.color){case Qe.Grey:t=ne.GREY;break;case Qe.None:t=ne.NONE;break;default:t=ne.RED}switch(i.code){case void 0:case null:n=null;break;case V.AuthenticityNotGuaranteed:n=P.AUTHENTICITY_NOT_GUARANTEED;break;case V.UnknownDevice:n=P.UNKNOWN_DEVICE;break;case V.UnsignedDevice:n=P.UNSIGNED_DEVICE;break;case V.UnverifiedIdentity:n=P.UNVERIFIED_IDENTITY;break;case V.SentInClear:n=P.SENT_IN_CLEAR;break;case V.VerificationViolation:n=P.VERIFICATION_VIOLATION}return{shieldColour:t,shieldReason:n}}function Bt(e){return be.apply(this,arguments)}function be(){return(be=c((function*(e){var r,{logger:t,legacyStore:n}=e;if(yield vr(),new mr(kr.Debug).turnOn(),yield n.containsData()){yield n.startup();var i=null;if(yield n.doTxn("readonly",[Y.STORE_ACCOUNT],(e=>{n.getAccount(e,(e=>{i=e}))})),i){var o=yield n.getMigrationState();if(!(o>=K.MEGOLM_SESSIONS_MIGRATED)){var s=yield Tt(t,n),a=yield Pt(t,n),c=1+s+a;t.info("Migrating data from legacy crypto store. ".concat(s," olm sessions and ").concat(a," megolm sessions to migrate."));var u=0;l(0);var d=(new TextEncoder).encode(e.legacyPickleKey);o===K.NOT_STARTED&&(t.info("Migrating data from legacy crypto store. Step 1: base data"),yield qt(e.http,e.userId,e.deviceId,n,d,e.storeHandle,t),o=K.INITIAL_DATA_MIGRATED,yield n.setMigrationState(o)),l(1),o===K.INITIAL_DATA_MIGRATED&&(t.info("Migrating data from legacy crypto store. Step 2: olm sessions (".concat(s," sessions to migrate).")),yield Ut(t,n,d,e.storeHandle,l),o=K.OLM_SESSIONS_MIGRATED,yield n.setMigrationState(o)),o===K.OLM_SESSIONS_MIGRATED&&(t.info("Migrating data from legacy crypto store. Step 3: megolm sessions (".concat(a," sessions to migrate).")),yield Vt(t,n,d,e.storeHandle,l),o=K.MEGOLM_SESSIONS_MIGRATED,yield n.setMigrationState(o)),null===(r=e.legacyMigrationProgressListener)||void 0===r||r.call(e,-1,-1),t.info("Migration from legacy crypto store complete")}}else t.debug("Legacy crypto store is not set up (no account found). Not migrating.")}function l(r){var t;u+=r,null===(t=e.legacyMigrationProgressListener)||void 0===t||t.call(e,u,c)}}))).apply(this,arguments)}function qt(e,r,t,n,i,o,s){return we.apply(this,arguments)}function we(){return(we=c((function*(e,r,t,n,i,o,s){var a=new nt;a.userId=new m(r),a.deviceId=new O(t),yield n.doTxn("readonly",[Y.STORE_ACCOUNT],(e=>n.getAccount(e,(e=>{a.pickledAccount=e??""}))));var c=yield te(n,i,"m.megolm_backup.v1");if(c){for(var u=!1,d=null;!u;)try{d=yield Kr(e),u=!0}catch(e){s.info("Failed to get backup version during migration, retrying in 2 seconds",e),yield T(2e3)}if(d&&"m.megolm_backup.v1.curve25519-aes-sha2"==d.algorithm)try{var l,g=x.fromBase64(c),y=null===(l=d.auth_data)||void 0===l?void 0:l.public_key;g.megolmV1PublicKey.publicKeyBase64==y?(a.backupVersion=d.version,a.backupRecoveryKey=c):s.debug("The backup key to migrate does not match the active backup version","Cached pub key: ".concat(g.megolmV1PublicKey.publicKeyBase64),"Active pub key: ".concat(y))}catch(e){s.warn("Failed to check if the backup key to migrate matches the active backup version",e)}}a.privateCrossSigningMasterKey=yield te(n,i,"master"),a.privateCrossSigningSelfSigningKey=yield te(n,i,"self_signing"),a.privateCrossSigningUserSigningKey=yield te(n,i,"user_signing"),yield Te.migrateBaseData(a,i,o)}))).apply(this,arguments)}function Tt(e,r){return Re.apply(this,arguments)}function Re(){return(Re=c((function*(e,r){var t;return e.debug("Counting olm sessions to be migrated"),yield r.doTxn("readonly",[Y.STORE_SESSIONS],(e=>r.countEndToEndSessions(e,(e=>t=e)))),t}))).apply(this,arguments)}function Pt(e,r){return Ke.apply(this,arguments)}function Ke(){return(Ke=c((function*(e,r){return e.debug("Counting megolm sessions to be migrated"),yield r.countEndToEndInboundGroupSessions()}))).apply(this,arguments)}function Ut(e,r,t,n,i){return Ee.apply(this,arguments)}function Ee(){return(Ee=c((function*(e,r,t,n,i){for(;;){var o=yield r.getEndToEndSessionsBatch();if(null===o)return;e.debug("Migrating batch of ".concat(o.length," olm sessions"));var s=[];for(var a of o){var c=new st;c.senderKey=a.deviceKey,c.pickle=a.session,c.lastUseTime=c.creationTime=new Date(a.lastReceivedMessageTs),s.push(c)}yield Te.migrateOlmSessions(s,t,n),yield r.deleteEndToEndSessionsBatch(o),i(o.length)}}))).apply(this,arguments)}function Vt(e,r,t,n,i){return Me.apply(this,arguments)}function Me(){return(Me=c((function*(e,r,t,n,i){for(;;){var o=yield r.getEndToEndInboundGroupSessionsBatch();if(null===o)return;e.debug("Migrating batch of ".concat(o.length," megolm sessions"));var s=[];for(var a of o){var c,u=a.sessionData,d=new ot;d.pickle=u.session,d.roomId=new R(u.room_id),d.senderKey=a.senderKey,d.senderSigningKey=null===(c=u.keysClaimed)||void 0===c?void 0:c.ed25519,d.backedUp=!a.needsBackup,d.imported=!0===u.untrusted,s.push(d)}yield Te.migrateMegolmSessions(s,t,n),yield r.deleteEndToEndInboundGroupSessionsBatch(o),i(o.length)}}))).apply(this,arguments)}function Nt(e){return Ie.apply(this,arguments)}function Ie(){return(Ie=c((function*(e){var{logger:r,legacyStore:t,olmMachine:n}=e;if((yield t.containsData())&&!((yield t.getMigrationState())>=K.ROOM_SETTINGS_MIGRATED)){var i={};for(var[o,s]of(yield t.doTxn("readwrite",[Y.STORE_ROOMS],(e=>{t.getEndToEndRooms(e,(e=>{i=e}))})),r.debug("Migrating ".concat(Object.keys(i).length," sets of room settings")),Object.entries(i)))try{var a=new fr;if("m.megolm.v1.aes-sha2"!==s.algorithm){r.warn("Room ".concat(o,": ignoring room with invalid algorithm ").concat(s.algorithm));continue}a.algorithm=J.MegolmV1AesSha2,a.sessionRotationPeriodMs=s.rotation_period_ms,a.sessionRotationPeriodMessages=s.rotation_period_msgs,yield n.setRoomSettings(new R(o),a)}catch(e){r.warn("Room ".concat(o,": ignoring settings ").concat(JSON.stringify(s)," which caused error ").concat(e))}r.debug("Completed room settings migration"),yield t.setMigrationState(K.ROOM_SETTINGS_MIGRATED)}}))).apply(this,arguments)}function te(e,r,t){return Ce.apply(this,arguments)}function Ce(){return(Ce=c((function*(e,r,t){var n=yield new Promise((r=>{e.doTxn("readonly",[Y.STORE_ACCOUNT],(n=>{e.getSecretStorePrivateKey(n,r,t)}))}));return n&&n.ciphertext&&n.iv&&n.mac?yield xr(n,r,t):n instanceof Uint8Array?ve(n):void 0}))).apply(this,arguments)}function xt(e){return De.apply(this,arguments)}function De(){return(De=c((function*(e){var{legacyCryptoStore:r,rustCrypto:t,logger:n}=e,i=yield t.getOwnIdentity();if(i&&!i.isVerified()){var o=yield At(r);if(o){var s=JSON.parse(i.masterKey);if(!s.keys||0===Object.keys(s.keys).length)return void n.error("Post Migration | Unexpected error: no master key in the rust session.");var a=Object.values(s.keys)[0];a&&a==o&&(n.info("Post Migration: Migrating legacy trusted MSK: ".concat(o," to locally verified.")),yield i.verify())}}}))).apply(this,arguments)}function At(e){return Oe.apply(this,arguments)}function Oe(){return(Oe=c((function*(e){var r=null;return yield e.doTxn("readonly","account",(t=>{e.getCrossSigningKeys(t,(e=>{var t=null==e?void 0:e.master;t&&0!=Object.keys(t.keys).length&&(r=Object.values(t.keys)[0])}))})),r}))).apply(this,arguments)}function ur(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function Lt(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ur(Object(t),!0).forEach((function(r){y(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ur(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function Wt(e){return Be.apply(this,arguments)}function Be(){return(Be=c((function*(e){var r,{logger:t}=e;t.debug("Initialising Rust crypto-sdk WASM artifact"),yield vr(),new mr(kr.Debug).turnOn(),t.debug("Opening Rust CryptoStore"),r=e.storePrefix?e.storeKey?yield le.openWithKey(e.storePrefix,e.storeKey):yield le.open(e.storePrefix,e.storePassphrase):yield le.open(),e.legacyCryptoStore&&(yield Bt(Lt({legacyStore:e.legacyCryptoStore,storeHandle:r},e)));var n=yield Ft(t,e.http,e.userId,e.deviceId,e.secretStorage,e.cryptoCallbacks,r,e.legacyCryptoStore);return r.free(),t.debug("Completed rust crypto-sdk setup"),n}))).apply(this,arguments)}function Ft(e,r,t,n,i,o,s,a){return qe.apply(this,arguments)}function qe(){return(qe=c((function*(e,r,t,n,i,o,s,a){e.debug("Init OlmMachine");var c=yield at.initFromStore(new m(t),new O(n),s);a&&(yield Nt({logger:e,legacyStore:a,olmMachine:c})),c.roomKeyRequestsEnabled=!1;var u=new Ct(e,c,r,t,n,i,o);if((yield c.registerRoomKeyUpdatedCallback((e=>u.onRoomKeysUpdated(e))),yield c.registerRoomKeysWithheldCallback((e=>u.onRoomKeysWithheld(e))),yield c.registerUserIdentityUpdatedCallback((e=>u.onUserIdentityUpdated(e))),yield c.registerDevicesUpdatedCallback((e=>u.onDevicesUpdated(e))),u.checkSecrets("m.megolm_backup.v1"),yield c.registerReceiveSecretCallback(((e,r)=>u.checkSecrets(e))),yield c.outgoingRequests(),a&&(yield a.containsData()))&&(yield a.getMigrationState())<K.INITIAL_OWN_KEY_QUERY_DONE){e.debug("Performing initial key query after migration");for(var d=!1;!d;)try{yield u.userHasCrossSigningKeys(t),d=!0}catch(r){e.error("Failed to check for cross-signing keys after migration, retrying",r)}yield xt({legacyCryptoStore:a,rustCrypto:u,logger:e}),yield a.setMigrationState(K.INITIAL_OWN_KEY_QUERY_DONE)}return u}))).apply(this,arguments)}export{Wt as initRustCrypto};